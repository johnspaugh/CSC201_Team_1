Standard ML of New Jersey [Version 110.99.8; 32-bit; April 25, 2025]
- type Integer_Constant = int
type Boolean_Constant = bool
datatype Variable = S of string
datatype Arithmatic_Op = Div | Minus | Plus | Times
datatype Relational_Op = Eq | Ge | Gt | Le | Lt | Ne
datatype Boolean_Op = And | Or
datatype Operator
  = AOp of Arithmatic_Op
  | BOp of Boolean_Op
  | ROp of Relational_Op
datatype Expression
  = BC of bool
  | EEO of Expression * Expression * Operator
  | IC of int
  | Var of Variable
datatype Instruction
  = IfThenElse of Expression * Instruction * Instruction
  | Seq of Instruction list
  | Skip
  | VE of Variable * Expression
  | WhileLoop of Expression * Instruction
datatype Type = TypeName1Bool | TypeName2Int
type Declaration = Variable * Type
type DeclarationList = Declaration list
type Program = DeclarationList * Instruction
val var_n = S "n" : Variable
val var_cur = S "cur" : Variable
val var_prev1 = S "prev1" : Variable
val var_prev2 = S "prev2" : Variable
val var_i = S "i" : Variable
val var_answer = S "answer" : Variable
val declaration_n = (S "n",TypeName2Int) : Variable * Type
val declaration_cur = (S "cur",TypeName2Int) : Variable * Type
val declaration_prev1 = (S "prev1",TypeName2Int) : Variable * Type
val declaration_prev2 = (S "prev2",TypeName2Int) : Variable * Type
val declaration_i = (S "i",TypeName2Int) : Variable * Type
val declaration_answer = (S "answer",TypeName2Int) : Variable * Type
val all_declarationList =
  [(S "n",TypeName2Int),(S "cur",TypeName2Int),(S "prev1",TypeName2Int),
   (S "prev2",TypeName2Int),(S "i",TypeName2Int),(S "answer",TypeName2Int)]
  : (Variable * Type) list
val n_assign_15 = VE (S "n",IC 15) : Instruction
val isequal = Eq : Relational_Op
val O_equal = ROp Eq : Operator
val exp_isEqual0 = EEO (Var (S "n"),IC 0,ROp Eq) : Expression
val Assign_answer = VE (S "answer",IC 2) : Instruction
val Assign_i = VE (S "answer",IC 1) : Instruction
val isequal1 = Eq : Relational_Op
val O_equal1 = ROp Eq : Operator
val exp_isEqual1 = EEO (Var (S "n"),IC 1,ROp Eq) : Expression
val Assign_answer_1 = VE (S "answer",IC 1) : Instruction
val Assign_prev2_2 = VE (S "prev2",IC 2) : Instruction
val Assign_prev1_1 = VE (S "prev1",IC 1) : Instruction
val islessthan = Lt : Relational_Op
val O_less = ROp Lt : Operator
val iLessthenN = EEO (Var (S "i"),Var (S "n"),ROp Lt) : Expression
val add = Plus : Arithmatic_Op
val O_add = AOp Plus : Operator
val expr_iplusplus = EEO (Var (S "i"),IC 1,AOp Plus) : Expression
val Instruction_iplusplus = VE (S "i",EEO (Var (S "i"),IC 1,AOp Plus))
  : Instruction
val expr_cur_p1ADDp2 = EEO (Var (S "prev1"),Var (S "prev2"),AOp Plus)
  : Expression
val Instruction_cur =
  VE (S "cur",EEO (Var (S "prev1"),Var (S "prev2"),AOp Plus)) : Instruction
val expr_var_prev1 = Var (S "prev1") : Expression
val Instruction_prev1 = VE (S "prev2",Var (S "prev1")) : Instruction
val expr_var_cur = Var (S "cur") : Expression
val Instruction_var_cur = VE (S "prev1",Var (S "cur")) : Instruction
val whileInstruction =
  Seq
    [VE (S "i",EEO (Var (S "i"),IC 1,AOp Plus)),
     VE (S "cur",EEO (Var (S "prev1"),Var (S "prev2"),AOp Plus)),
     VE (S "prev2",Var (S "prev1")),VE (S "prev1",Var (S "cur"))]
  : Instruction
val instuction_while =
  WhileLoop
    (EEO (Var (S "i"),Var (S "n"),ROp Lt),
     Seq
       [VE (S "i",EEO (Var (S #),IC 1,AOp Plus)),
        VE (S "cur",EEO (Var (S #),Var (S #),AOp Plus)),
        VE (S "prev2",Var (S "prev1")),VE (S "prev1",Var (S "cur"))])
  : Instruction
val var_cur_expr = Var (S "cur") : Expression
val Instruction_answer_cur = VE (S "answer",Var (S "cur")) : Instruction
val elseInstruction =
  Seq
    [VE (S "prev2",IC 2),VE (S "prev1",IC 1),
     Seq
       [VE (S "i",EEO (Var (S #),IC 1,AOp Plus)),
        VE (S "cur",EEO (Var (S #),Var (S #),AOp Plus)),
        VE (S "prev2",Var (S "prev1")),VE (S "prev1",Var (S "cur"))],
     VE (S "answer",Var (S "cur"))] : Instruction
val Instruction_else =
  IfThenElse
    (EEO (Var (S "n"),IC 1,ROp Eq),VE (S "answer",IC 1),
     Seq
       [VE (S "prev2",IC 2),VE (S "prev1",IC 1),
        Seq
          [VE (S "i",EEO (#,#,#)),VE (S "cur",EEO (#,#,#)),
           VE (S "prev2",Var (S #)),VE (S "prev1",Var (S #))],
        VE (S "answer",Var (S "cur"))]) : Instruction
val Instruction_ifthenelse =
  IfThenElse
    (EEO (Var (S "n"),IC 0,ROp Eq),VE (S "answer",IC 2),
     IfThenElse
       (EEO (Var (S "n"),IC 1,ROp Eq),VE (S "answer",IC 1),
        Seq
          [VE (S "prev2",IC 2),VE (S "prev1",IC 1),
           Seq [VE (#,#),VE (#,#),VE (#,#),VE (#,#)],
           VE (S "answer",Var (S #))])) : Instruction
val all_instructions =
  Seq
    [VE (S "n",IC 15),
     IfThenElse
       (EEO (Var (S "n"),IC 0,ROp Eq),VE (S "answer",IC 2),
        IfThenElse
          (EEO (Var (S #),IC 1,ROp Eq),VE (S "answer",IC 1),
           Seq [VE (#,#),VE (#,#),Seq [#,#,#,#],VE (#,#)]))] : Instruction
val Program_Lucus =
  ([(S "n",TypeName2Int),(S "cur",TypeName2Int),(S "prev1",TypeName2Int),
    (S "prev2",TypeName2Int),(S "i",TypeName2Int),(S "answer",TypeName2Int)],
   Seq
     [VE (S "n",IC 15),
      IfThenElse
        (EEO (Var (S "n"),IC 0,ROp Eq),VE (S "answer",IC 2),
         IfThenElse
           (EEO (Var #,IC #,ROp #),VE (S #,IC #),Seq [VE #,VE #,Seq #,VE #]))])
  : (Variable * Type) list * Instruction
- 
